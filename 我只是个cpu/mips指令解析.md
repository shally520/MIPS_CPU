## mips
mips有三种指令格式（所有指令都是32位长）
1. R格式
```<opcode>,rs,rt,rd,shamt,funct```
2. I格式(用于有立即数的指令)
```<opcode>,rs,rt,offset```
3. J格式(无条件跳转并连接jal)
```<opcode>,address```
## R类型指令
```<opcode>,rs,rt,rd,shamt,funct```

opcpde(6)操作码，rs(5)第1个源操作数，rt(5)第2个源操作数，rd(5)目标寄存器(放结果)，shamt(5)偏移量，funct(6)函数码

and、or、xor、nor这4条指令都是R类型指令，并且指令码都是6'b000000，也就是MIPS32指令集架构中定义的SPECIAL类，需要依据指令中0-5bit功能码的值进一步判断是哪一种指令

指令码前六位，功能码后六位 
1. 当功能码是6'b100100时，表示是and指令，逻辑“与”运算
    - 指令用法为：and rd, rs, rt
    - 指令作用为：rd <- rs AND rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行逻辑“与”运算，运算结果保存到地址为rd的通用寄存器中。

2. 当功能码是6'b100101时，表示是or指令，逻辑“或”运算
    - 指令用法为：or rd, rs, rt
    - 指令作用为：rd <- rs OR rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行逻辑“或”运算，运算结果保存到地址为rd的通用寄存器中。

3. 当功能码是6'b100110时，表示是xor指令，异或运算
    - 指令用法为：xor rd, rs, rt
    - 指令作用为：rd <- rs XOR rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行逻辑“异或”运算，运算结果保存到地址为rd的通用寄存器中。

4. 当功能码是6'b100111时，表示是nor指令，或非运算
    - 指令用法为：nor rd, rs, rt
    - 指令作用为：rd <- rs NOR rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行逻辑“或非”运算，运结果保存到地址为rd的通用寄存器中。



以下是sll,sllv,sra,srav,srl,srlv指令，他们的opcode都是6'b000000，也就是都是SPECIAL类,需要根据funct进行区别
1. 当功能码是6'b000000，表示是sll指令，逻辑左移
    - 指令用法为：sll rd, rt, sa
    - 指令作用为：rd <- rt << sa (logic)，将地址为rt的通用寄存器的值，向左移sa位，空出来的位置使用0填充，结果保存到地址为rd的通用寄存器中。

2. 当功能码是6'b000010，表示是srl指令，逻辑右移
    - 指令用法为：srl rd, rt, sa
    - 指令作用为：rd <- rt >> sa (logic)，将地址为rt的通用寄存器的值，向右移sa位，空出来的位置使用0填充，结果保存到地址为rd的通用寄存器中。

3. 当功能码是6'b000011，表示是sra指令，算术右移
    - 指令用法为：sra rd, rt, sa
    - 指令作用为：rd <- rt >> sa (arithmetic)，将地址为rt的通用寄存器的值，向右移sa位，空出来的位置使用rt[31]的值填充，结果保存到地址为rd的通用寄存器中。

4. 当功能码是6'b000100，表示是sllv指令，逻辑左移
    - 指令用法为：sllv rd, rt, rs
    - 指令作用为：rd <- rt << rs[4:0](logic)，将地址为rt的通用寄存器的值，向左移位，空出来的位置使用0填充，结果保存到地址为rd的通用寄存器中。移位位数由地址为rs的寄存器值的0-4bit确定。

5. 当功能码是6'b000110，表示是srlv指令，逻辑右移
    - 指令用法为：srlv rd, rt, rs
    - 指令作用为：rd <- rt >> rs[4:0](logic)，将地址为rt的通用寄存器的值，向右移位，空出来的位置使用0填充，结果保存到地址为rd的通用寄存器中。移位位数由地址为rs的寄存器值的0-4bit确定。

6. 当功能码是6'b000111，表示是srav指令，算术右移
    - 指令用法为：srav rd, rt, rs
    - 指令作用为：rd <- rt >> rs[4:0](arithmetic)，将地址为rt的通用寄存器的值，向右移位，空出来的位置使用rt[31]填充，结果保存到地址为rd的通用寄存器中。移位位数由地址为rs的寄存器值的0-4bit确定。

nop、ssnop、sync这3条指令都是R类型指令，并且指令码都是6'b000000，也就是都是SPECIAL类。

这6条指令都是R类型指令，并且指令码都是6'b000000，即均为SPECIAL类指令，同时，指令第6-10bit都为0，可以依据指令中0-5bit功能码的值判断是哪一种指令。各指令的用法及作用说明如下。
1. 当功能码为6'b001011时，表示是movn指令
    - 指令用法为：movn rd, rs, rt
    - 指令作用为：if rt ≠0 then rd <- rs，判断地址为rt的通用寄存器的值，如果不为零，那么将地址为rs的通用寄存器的值赋给地址为rd的通用寄存器，反之，保持地址为rd的通用寄存器不变。movn是Move Conditional on Not Zero的意思。

2. 当功能码为6'b001010时，表示是movz指令
    - 指令用法为：movz rd, rs, rt
    - 指令作用为：if rt = 0 then rd <- rs，与上面movn指令的作用正好相反，判断地址为rt的通用寄存器的值，如果为零，那么将地址为rs的通用寄存器的值赋给地址为rd的通用寄存器，反之，保持地址为rd的通用寄存器不变。movz是Move Conditional on Zero的意思。

3. 当功能码为6'b010000时，表示是mfhi指令
    - 指令用法为：mfhi rd
    - 指令作用为：rd <- hi，将特殊寄存器HI的值赋给地址为rd的通用寄存器。

4. 当功能码为6'b010010时，表示是mflo指令
    - 指令用法为：mflo rd
    - 指令作用为：rd <- lo，将特殊寄存器LO的值赋给地址为rd的通用寄存器。

5. 当功能码为6'b010001时，表示是mthi指令
    - 指令用法为：mthi rs
    - 指令作用为：hi <- rs，将地址为rs的通用寄存器的值赋给特殊寄存器HI。

6. 当功能码为6'b010011时，表示是mtlo指令
    - 指令用法为：mtlo rs
    - 指令作用为：lo <- rs，将地址为rs的通用寄存器的值赋给特殊寄存器LO。


## I类型指令
```<opcode>,rs,rt,offset```

opcode(6)操作码，rs(5)第1个源操作数寄存器，rt(5)目标寄存器(放结果)address(16)地址行对基址偏移量
数据装入：Rt= Mem[Rs+Address]
数据存储：Mem[Rs+Address]=Rt
1. 当指令码是6'b001111，表示是lui指令
    - 指令用法为：lui rt, immediate
    - 指令作用为：rt <- immediate || 016，将指令中的16bit立即数保存到地址为rt的通用寄存器的高16位，另外，地址为rt的通用寄存器的低16位使用0填充。

5. 当指令码是6'b001100，表示是andi指令，逻辑“与”运算
    - 指令用法为：andi rt, rs, immediate
    - 指令作用为：rt <- rs AND zero_extended(immediate)，将地址为rs的通用寄存器的值，与指令中立即数进行零扩展后的值进行逻辑“与”运算，运算结果保存到地址为rt的通用寄存器中。

6. 当指令码是6'b001110，表示是xori指令，异或运算
    - 指令用法为：xori rt, rs, immediate
    - 指令作用为：rt <- rs XOR zero_extended(immediate)，将地址为rs的通用寄存器的值，与指令中立即数进行零扩展后的值进行逻辑“异或”运算，运算结果保存到地址为rt的通用寄存器中。
## J类型指令
```<opcode>,address```
opcode(6)操作码,address(26)目标地址

[mips所有指令](https://blog.csdn.net/qq_39559641/article/details/89608132?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control)

## 算术指令
add、addu、sub、sub、slt、sltu指令,这6条指令都是R类型指令，并且指令码都是6'b000000，即SPECIAL类，另外第6-10bit都为0，需要依据指令中0-5bit功能码的值进一步判断是哪一种指令。
1. 当功能码是6'b100000时，表示是add指令，加法运算
    - 指令用法为：add rd, rs, rt
    - 指令作用为：rd <- rs + rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行加法运算，结果保存到地址为rd的通用寄存器中。但是有一种特殊情况：如果加法运算溢出，那么会产生溢出异常，同时不保存结果。

2. 当功能码是6'b100001时，表示是addu指令，加法运算
    - 指令用法为：addu rd, rs, rt
    - 指令作用为：rd <- rs + rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行加法运算，结果保存到地址为rd的通用寄存器中。与add指令不同之处在于addu指令不进行溢出检查，总是将结果保存到目的寄存器。

3. 当功能码是6'b100010时，表示是sub指令，减法运算
    - 指令用法为：sub rd, rs, rt
    - 指令作用为：rd <- rs - rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行减法运算，结果保存到地址为rd的通用寄存器中。但是有一种特殊情况：如果减法运算溢出，那么产生溢出异常，同时不保存结果。

4. 当功能码是6'b100011时，表示是subu指令，减法运算
    - 指令用法为：subu rd, rs, rt
    - 指令作用为：rd <- rs - rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值进行减法运算，结果保存到地址为rd的通用寄存器中。与sub指令不同之处在于subu指令不进行溢出检查，总是将结果保存到目的寄存器。

5. 当功能码是6'b101010时，表示是slt指令，比较运算
    - 指令用法为：slt rd, rs, rt
    - 指令作用为：rd <- (rs < rt)，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值按照有符号数进行比较，如果前者小于后者，那么将1保存到地址为rd的通用寄存器中，反之，将0保存到地址为rd的通用寄存器中。

6. 当功能码是6'b101011时，表示是sltu指令，比较运算
    - 指令用法为：sltu rd, rs, rt
    - 指令作用为：rd <- (rs < rt)，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值按照无符号数进行比较，如果前者小于后者，那么将1保存到地址为rd的通用寄存器中，反之，将0保存到地址为rd的通用寄存器中。

addi、addiu、slti、slti指令，这4条指令都是I类型指令，能够依据指令中26-31bit指令码的值判断是哪一种指令。
1. 当指令码是6'b001000时，表示是addi指令，加法运算
    - 指令用法为：addi rt, rs, immediate
    - 指令作用为：rt <- rs + (sign_extended)immediate，将指令中16位立即数进行符号扩展，与地址为rs的通用寄存器的值进行加法运算，结果保存到地址为rt的通用寄存器中。但是有一个特殊情况：如果加法运算溢出，那么产生溢出异常，同时不保存结果。

2. 当指令码是6'b001001时，表示是addiu指令，加法运算
    - 指令用法为：addiu rt, rs, immediate
    - 指令作用为：rt <- rs + (sign_extended)immediate，将指令中16位立即数进行符号扩展，与地址为rs的通用寄存器的值进行加法运算，结果保存到地址为rt的通用寄存器中。与addi指令的区别在于addiu指令不进行溢出检查，总是将结果保存到目的寄存器。

3. 当指令码是6'b001010时，表示是slti指令，比较运算
    - 指令用法为：slti rt, rs, immediate
    - 指令作用为：rt <- (rs < (sign_extended)immediate)，将指令中16位立即数进行符号扩展，与地址为rs的通用寄存器的值按照有符号数比较，如果前者大于后者，那么将1保存到地址为rt的通用寄存器中，反之，将0保存到地址为rt的通用寄存器中。

4. 当指令码是6'b001011时，表示是sltiu指令，比较运算
    - 指令用法为：sltiu rt, rs, immediate
    - 指令作用为：rt<- (rs < (sign_extended)immediate)，将指令中16位立即数进行符号扩展，与地址为rs的通用寄存器的值按照无符号数比较，如果前者大于后者，那么将1保存到地址为rt的通用寄存器中，反之，将0保存到地址为rt的通用寄存器中。

clo、clz指令这2条指令都是R类型指令，并且指令码都是6'b011100，在MIPS32指令集架构中表示SPECIAL2类，另外第6-10bit都为0，需要依据指令中0-5bit功能码的值进一步判断是哪一种指令。
1. 当功能码是6'b100000时，表示是clz指令，计数运算
    - 指令用法为：clz rd, rs
    - 指令作用为：rd <- coun_leading_zeros rs，对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“1”的位，将该位之前“0”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为0（即0x00000000），那么将32保存到地址为rd的通用寄存器中。

2. 当功能码是6'b100001时，表示是clo指令，计数运算
    - 指令用法为：clo rd, rs
    - 指令作用为：rd <- coun_leading_ones rs，对地址为rs的通用寄存器的值，从其最高位开始向最低位方向检查，直到遇到值为“0”的位，将该位之前“1”的个数保存到地址为rd的通用寄存器中，如果地址为rs的通用寄存器的所有位都为1（即0xFFFFFFFF），那么将32保存到地址为rd的通用寄存器中。

multu、mult、mul指令，这3条指令都是R类型指令，并且mul指令的指令码是SPECIAL2，mult、multu的指令码是SPECIAL。
1. 当指令码为SPECIAL2，功能码为 6'b000010时，表示是mul指令，乘法运算
    - 指令用法为：mul rd, rs, st
    - 指令作用为：rd <- rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到地址为rd的通用寄存器中。

2. 当指令码为SPECIAL，功能码为6'b011000时，表示是mult指令，乘法运算
    - 指令用法为：mult rs, st
    - 指令作用为：{hi, lo} <- rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值作为有符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中。

3. 当指令码为SPECIAL，功能码为6'b011001时，表示是multu指令，乘法运算
    - 指令用法为：multu rs, st
    - 指令作用为：{hi, lo} <- rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值作为无符号数相乘，乘法结果的低32bit保存到LO寄存器中，高32bit保存到HI寄存器中。与mult指令的区别在于multu指令执行中将操作数作为无符号数进行运算。

madd、maddu、msub、msubu，各指令的格式如图7-11所示。从图中可知这4条指令的指令码都是SPECIAL2，第6-15bit都为0，可以依据第0-5bit的功能码确定是哪一种指令。
1. 当功能码是6'b000000时，表示是madd指令，有符号乘累加运算
      指令用法为：madd rs, rt
      指令作用为：{HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为有符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。此处{HI, LO}表示的是HI、LO寄存器连接形成的64位数，HI是高32位，LO是低32位。

2. 当功能码是6'b000001时，表示是maddu指令，无符号乘累加运算
      指令用法为：maddu rs, rt
      指令作用为：{HI, LO} <- {HI, LO} + rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为无符号数进行乘法运算，运算结果与{HI, LO}相加，相加的结果保存到{HI, LO}中。

3. 当功能码是6'b000100时，表示是msub指令，有符号乘累减运算
      指令用法为：msub rs, rt
      指令作用为：{HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为有符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中。

4. 当功能码是6'b000101时，表示是msubu指令，无符号乘累减运算
      指令用法为：msubu rs, rt
      指令作用为：{HI, LO} <- {HI, LO} - rs × rt，将地址为rs的通用寄存器的值，与地址为rt的通用寄存器的值，作为无符号数进行乘法运算。然后使用{HI, LO}减去乘法结果，相减的结果保存到{HI, LO}中。




